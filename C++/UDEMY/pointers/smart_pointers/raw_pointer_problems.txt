ISSUES WITH RAW POINTERS

C++ PROVEE FLIXIBILIDAD ABSOLUTA CON EL MANEJO DE LA MEMORIA
    -> ALLOCATION
    -> DEALLOCATION
    -> LIFETIME MANAGEMENT


ALGUNOS DE LOS PROBLEMAS MAS SERIOS DE RAW POINTERS
    -> UNINITIALIZED RAW POINTERS
    -> MEMORY LEAKS
    -> DANGLING POINTERS
    -> NO EXCEPTION SAFE

OWNERSHIP?
    -> WHO OWNS THE POINTER?
    -> WHEN SHOULD THE POINTER BE DELETED?

PARA TODOS ESTOS PROBLEMAS ESTÁ EL SMART POINTER

QUE SON LOS SMART POINTERS?
    -> OBJETOS
    -> CAN ONLY POINT TO HEAP-ALLOCATED MEMORY
    -> AUTOMATICALLY CALL DELETE WHEN NO LONGER NEEDED
    -> ADHERE TO RAII PRINCIPLES (Resource Acquisition Is Initialization)

CAN HAVE CUSTOM DELETERS

SE NECESITA LA LIBRERIA #include <memory>

ESTAN DEFINIDOS POR CLASS TEMPLATES
    EN REALIDAD ES UN WRAPPER ALREDEDOR DE UN RAW POINTER
    -> OVERLOADED OPERATORS
        DEREFERENCE
        MEMBER SELECTION
        POINTER ARITHMETIC NOT SUPPORTED
    
    -> CAN HAVE CUSTOM DELETERS

std::smart_pointer <Some_Class> ptr = ...
ptr->method();
cout << (*ptr) << endl;